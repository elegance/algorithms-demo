## 算法相关
---

#### 基础排序 - O(N^2)
一般实现都是两层循环：
* 冒泡排序，一轮内层循环确定数组最后一个未排序位置的值
* 选择排序，一轮内层循环选出最小值所在的索引，然后放在未排序的首位
* 插入排序，外层循环从1开始，内层循环索引**递减往前**挨个尝试插排，不可插入时可提前退出内层循环
* 希尔排序，基本原理与插入排序一致，不是挨个递减，**跳跃性的递减**，在插入排序方法外加入一层跳跃值的递减，比如`h /=3 `，直到其等于1

1. 选择排序，记忆口诀：**选出最小排首位** (首位是指剩余未排序位置中的首位，第1轮确定第1个位置，第2轮确定第2个位置...)
    * 特点：
        - 一轮大循环只发生一次交换
        - 取最小要遍历比较，故不可提前结束
    * 代码：
        - [java选择排序的实现](./java/src/main/java/org/orh/sorting/basic/SelectionSort.java)
        - [java选择排序泛型支持](./java/src/main/java/org/orh/sorting/basic/ext/SelectionSortObject.java)

2. 插入排序，记忆口诀：**挨个往前比较插入** (往前比较，意味着循环开始从第二个元素开始)
    * 特点：
        - 挨个比较不满足条件时，可**提前退出循环**，面对接近有序的数据有较强的性能提升
        - 挨个比较插入，发生多次swap (一次 swap = 3次赋值)
    * 代码：
        - [java插入排序的实现](./java/src/main/java/org/orh/sorting/basic/InsertionSort.java)
        - [java插入排序优化swap](./java/src/main/java/org/orh/sorting/basic/ext/InsertionSortOptimization.java)
    * 扩展
        - 希尔排序，插入排序：插入排序是挨个往前比较，而希尔排序则是相隔 N个元素的来比较，然后递减这个N至1 -

3. 冒泡排序
    

#### 高级排序 - O(NlogN)
高级排序一般理想时间复杂度是O(NlogN)，但是不同的数据、不同的排序方式，还有实现差异，可能使时间复杂度退化为O(N^2)
* 归并排序：递归将数据中间一分为二，直到不可再分，最终关注问题是**怎么将两个分别有序的数组，合成一个有序数组** 利用辅助空间aux。
* 快速排序：将选定的基准元素防止到它最终排好序的位置，即左边的元素比它小，右边的元素比它大。
* 堆排序：利用堆数据结构的特点，完全二叉树，最大堆节点值大于子节点值。


1. 归并排序，核心就是利用辅助空间将两个分别有序的数组组成一个数组
    * 特点：
        - 自顶向上，递归拆分 [left, mid], [mid+1,  right]
    * 代码
        - [java递归排序的实现](./java/src/main/java/org/orh/sorting/advance/MergeSort.java)
            优化点：
                - 在拆分的过程中，如果区间小于某个值(比如15)，可以使用O(N^2)的排序算法，比如这里结合了插入算法
                - 如果左区间最后的元素 小于 右区间的开始元素则可以不执行 merge了

2. 快速排序

3. 堆排序