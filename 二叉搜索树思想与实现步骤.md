## 二叉搜索树

解决**查找**问题

#### 二分查找法

二分查找法，限制：**对于有序数列，才能使用二分查找法（排序的作用）**，排序作为子过程。

#### 二分查找法的变种
floor/ceil: 首次出现的位置，最后出现的位置，另外如果没有查到元素，floor将会得到比查找元素小的最近的元素，ceil则会返回比查找元素大的最近的元素。

#### 一、二分搜索树基础
查找表的实现，字典数据结构，key-value，key 是数值 直接作为索引可能会稀疏浪费空间，key为对象不能直接使用数组索等情况。
| 实现方式 | 维护（增/删） | 查找 | 
| :--- | :---: | :---: |
| 普通数组 | O(N) | O(N) |
| 顺序数组 | O(N) | O(logN) |
| 二分搜索树 | O(logN) | O(logN) |

**优势：**
* 高效，高效的查找，还可以高效的插入、删除数据
* 可以方便地回答很多数据之间的关系问题
    * min, max, floor, ceil, rank(看这个数据是第几名), select(第N名是谁)

**定义:**
* 二叉树
* `节点值` **大于** `左孩子` 
* `节点值` **小于** `右孩子`


![](http://wx3.sinaimg.cn/large/929194b4gy1fkwvsgpz5bj20ob0cjn0l.jpg)

#### 二、二分搜索树的实现BST
1. 定义`BST`数据基本结构:
```java
class BST<K, V> {
    Node root; // 根节点
    int count; // 总节点数量
    class Node<K, V> {
        K k;
        V v;
        Node left;
        Node right;
    }
}
```
2. 二分搜索树添加元素
与根比较，递归往下插，大往右插，小往左插, 特殊情况：如果相等，覆盖
```
void insert(K k, V v); // 向二分查找树中添加-调用以下 insert(root, k, v)
Node insert(Node node, K k, V v); // 向以指定节点为根的二叉树中新增，并返回插入后树的根，节点内会判断、递归
boolean contain(K k)
V search(K k)
```
3. 二分搜索树的遍历
深度优先：
* 前序遍历
* 中序遍历: 从小到大的顺序依次输出
* 后续遍历: 释放节点资源

广度优先：
* 层序遍历 - 队列辅助（拿时放孩子： 根推进队列，循环队列，不会空则拿元素出来，将左右孩子分别如队）

4. 二叉搜索树最难的一个操作：删除节点
找到节点容易，删除节点容易，难度实在删除了要保持二叉搜索树的性质。
* 先考虑较为简单的：删除最大节点、删除最小节点 
    * 助记1：最小在树的左下角-其可能有右节点、也可能没右节点 - 删除后，其父节点该指向空/或其右子节点(递归实现)
    * 助记2：把最小节点想象成 "<" 号顶点，最大节点想象成 ">"号的顶点，目标就是让顶点移除后，上、下连起来顶点下面的线不一定存在
* 删除指定节点 - 画图思考，不像删除最大、最小节点用左、或右字节点代替的思路，而是找删除节点的**同质节点**
    * 同质节点：节点的左子节点比节点小，右子节点比节点大，找到另外一个有这个性质的元素即可代替删除节点即可（左边右边都有可能存在这样的元素）