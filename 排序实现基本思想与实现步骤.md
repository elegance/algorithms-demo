
## 堆排序
#### 一、要使用堆排序，我们要现有一个堆的实现：

堆同时具有以下要求: (这里我举出的是最大堆MaxHeap)
* 二叉树：节点最多只有两个子节点
* 完全二叉树：中间不会有"空白"位置，空白只能在右侧叶子节点
* `节点值` **大于** `子节点值`

画出堆的树形图，观察堆可以得到以下规律，可以供我们在实现堆时使用:（经典的数组实现堆方式 索引是从1开始的，也就是空出数组的第一个索引，可以得到索引有以下特征，如果按0也可以得到类似规律）
* `父节点索引`是"节点索引"的**1/2** （即可得到：如果节点索引为`n`, 则`左子节点索引`为`2n`, `右子节点`索引为`2n+1`）

有了以上认识后，就可以按下面的步骤来实现一个最大堆了：

#### 实现堆`MaxHeap`
1. 初始化
    1. capacity 容量，data[capacity+1] 用于存储堆数据，count元素个数
2. insert(item) 增加元素
    1. 入：放入至最尾部首个的空白(即count)位置
    2. 维：维护堆的完整性，shift up: 位置与父节点比较，比父节点大则swap，递归进行
3. item extractMax() 获取元素
    1. 取：元素只能取**顶端最大**的元素即 `data[1]`
    2. 填：空白处用最后一个元素(`arr[count]`), count--
    3. 维：shift down，向左/右/不移，子节点哪个大就和哪个swap
4. 实现`heapify`将数组转换为`MaxHeap`的构造函数(以上三步即完成了堆的基本操作，后面一般都有的扩展支持)
    1. 入：建立新数组，前保留一个空位，把数组值复制进来(`System.arraycopy(arr, 0, data, 1, arr.length)`)
    2. 思考：画个简图看下，此时可以把每个叶子节点看成是一个二叉堆，即只有一个节点的堆，那么只要从最后一个非叶子节点递减的shift down即可。观察得到规律**最后一个非叶子节点索引是节点数 n/2**
    3. 维：递归 `i = n / 2, shiftDown(i), i--`
5. 可增加方法`size()`返回`count`，`isEmpty()`返回是否为空

堆主要可用于动态的数据排序，比如优先队列.

#### 二、使用堆进行排序
1. 利用数组构造出一个堆`MaxHeap`，然后从堆中逆序取出替换原数组即可

2. 优化: 第一种方法使用了`开辟了额外的空间`，根据`堆`数据结构的思想，我们可以在数组上直接的用堆思想进行`原地排序`
索引从0开始规律微调为为以下：
```
parent(i) = (i-1) / 2
left child (i) = 2*i + 1
right child (i) = 2*i + 2
最后一个非叶子节点索引：(count-1) / 2
```
1. 从最后一非叶子节点开始循环shiftDown操作